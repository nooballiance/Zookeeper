'use strict';

var _fs = require('fs');

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _homePath = require('home-path');

var _homePath2 = _interopRequireDefault(_homePath);

var _mv = require('mv');

var _mv2 = _interopRequireDefault(_mv);

var _pify = require('pify');

var _pify2 = _interopRequireDefault(_pify);

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _pinkiePromise = require('pinkie-promise');

var _pinkiePromise2 = _interopRequireDefault(_pinkiePromise);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var _regeneratorRuntime = require('regenerator-runtime');

var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars

var Promise = global.Promise || _pinkiePromise2.default;
// import _npmrc from 'rc';

var debug = (0, _debug3.default)('libui-download');
// const npmrc = _npmrc('npm');
var mkdir = (0, _pify2.default)(_mkdirp2.default, Promise);

var pathExists = function pathExists(fp) {
	return new Promise(function (resolve) {
		(0, _fs.access)(fp, function (err) {
			resolve(!err);
		});
	});
};

function nodePlatformToOS(arch) {
	switch (arch) {
		case 'darwin':
			return 'osx';
		case 'win32':
			return 'windows';
		case 'linux':
			return 'linux';
		default:
			throw new Error('Unknown platform ' + arch);
	}
}

function cacheDir() {
	var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var homeDir = (0, _homePath2.default)();
	return opts.cache || _path2.default.join(homeDir, './.libui');
}

function mkCacheDir(cache) {
	var localCache;
	return _regeneratorRuntime2.default.async(function mkCacheDir$(_context) {
		while (1) {
			switch (_context.prev = _context.next) {
				case 0:
					_context.prev = 0;
					_context.next = 3;
					return _regeneratorRuntime2.default.awrap(mkdir(cache));

				case 3:
					return _context.abrupt('return', cache);

				case 6:
					_context.prev = 6;
					_context.t0 = _context['catch'](0);

					if (!(_context.t0.code !== 'EACCES')) {
						_context.next = 11;
						break;
					}

					debug('mkCacheDir error: ', _context.t0.stack);
					throw _context.t0;

				case 11:

					// try local folder if homedir is off limits (e.g. some linuxes return '/' as homedir)
					localCache = _path2.default.resolve('./.libui');
					_context.next = 14;
					return _regeneratorRuntime2.default.awrap(mkdir(localCache));

				case 14:
					return _context.abrupt('return', localCache);

				case 15:
				case 'end':
					return _context.stop();
			}
		}
	}, null, this, [[0, 6]]);
}

function buildUrl(opts, filename) {
	var url = process.env.NPM_CONFIG_LIBUI_MIRROR || process.env.LIBUI_MIRROR || opts.mirror || 'https://github.com/parro-it/libui/releases/download/';

	url += process.env.LIBUI_CUSTOM_DIR || opts.customDir || opts.version;
	url += '/';
	url += process.env.LIBUI_CUSTOM_FILENAME || opts.customFilename || filename;
	return url;
}

function download(opts) {
	var platform, arch, version, symbols, filename, url, cache, cachedZip, exists, actualCache, tmpdir, target;
	return _regeneratorRuntime2.default.async(function download$(_context2) {
		while (1) {
			switch (_context2.prev = _context2.next) {
				case 0:
					platform = nodePlatformToOS(opts.platform || _os2.default.platform());
					arch = opts.arch || _os2.default.arch();
					version = opts.version;
					symbols = opts.symbols || false;
					filename = 'libui-shared-' + platform + '-' + arch + '-' + version + (symbols ? '-symbols' : '') + '.tar.gz';

					if (version) {
						_context2.next = 7;
						break;
					}

					throw new Error('must specify version');

				case 7:
					url = buildUrl(opts, filename);
					cache = cacheDir(opts.cache);

					/*
     	var strictSSL = true;
     	if (opts.strictSSL === false || npmrc['strict-ssl'] === false) {
     		strictSSL = false;
     	}
     
     	var proxy;
     
     	if (npmrc && npmrc.proxy) {
     		proxy = npmrc.proxy;
     	}
     
     	if (npmrc && npmrc['https-proxy']) {
     		proxy = npmrc['https-proxy'];
     	}
     */

					debug('info', { cache: cache, filename: filename, url: url });

					cachedZip = _path2.default.join(cache, filename);
					_context2.next = 13;
					return _regeneratorRuntime2.default.awrap(pathExists(cachedZip));

				case 13:
					exists = _context2.sent;

					if (!exists) {
						_context2.next = 17;
						break;
					}

					debug('zip exists', cachedZip);
					return _context2.abrupt('return', cachedZip);

				case 17:

					debug('creating cache/tmp dirs');

					// otherwise download it
					_context2.next = 20;
					return _regeneratorRuntime2.default.awrap(mkCacheDir(cache));

				case 20:
					actualCache = _context2.sent;

					cachedZip = _path2.default.join(actualCache, filename); // in case cache dir changed

					// download to tmpdir
					tmpdir = _path2.default.join(_os2.default.tmpdir(), 'libui-tmp-download-' + process.pid + '-' + Date.now());
					_context2.next = 25;
					return _regeneratorRuntime2.default.awrap(mkdir(tmpdir));

				case 25:
					debug(tmpdir + 'created');

					debug('downloading zip', url, 'to', tmpdir);

					target = _path2.default.join(tmpdir, filename);
					_context2.next = 30;
					return _regeneratorRuntime2.default.awrap(new Promise(function (resolve, reject) {
						var res = (0, _request2.default)(url);

						var finish = function finish() {
							debug('end stream reached', target, cachedZip);
							(0, _mv2.default)(target, cachedZip, function (err) {
								if (err) {
									reject(err);
								} else {
									resolve(cachedZip);
								}
							});
						};

						res.on('response', function (resp) {
							debug(resp.statusCode);
							if (resp.statusCode === 404) {
								return reject(new Error('Failed to find libui ' + version + ' for ' + (opts.platform || _os2.default.platform()) + '-' + arch + ' at ' + url));
							}
							var fileWrite = res.pipe((0, _fs.createWriteStream)(target));

							fileWrite.on('finish', finish);
							fileWrite.on('error', reject);
						});
					}));

				case 30:
					return _context2.abrupt('return', _context2.sent);

				case 31:
				case 'end':
					return _context2.stop();
			}
		}
	}, null, this);
}

download.pathExists = pathExists;
download.cacheDir = cacheDir;
module.exports = download;
